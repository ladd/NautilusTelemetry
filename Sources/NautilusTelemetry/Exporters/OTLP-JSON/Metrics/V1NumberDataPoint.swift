//
// V1NumberDataPoint.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
	import AnyCodable
#endif

@available(*, deprecated, renamed: "OTLP.V1NumberDataPoint")
typealias V1NumberDataPoint = OTLP.V1NumberDataPoint

extension OTLP {
	/** NumberDataPoint is a single data point in a timeseries that describes the time-varying scalar value of a metric. */
	struct V1NumberDataPoint: Codable, Hashable {
		/** The set of key/value pairs that uniquely identify the timeseries from where this point belongs. The list may be empty (may contain 0 elements). Attribute keys MUST be unique (it is not allowed to have more than one attribute with the same key). */
		var attributes: [V1KeyValue]?
		/** StartTimeUnixNano is optional but strongly encouraged, see the the detailed comments above Metric.  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970. */
		var startTimeUnixNano: String?
		/** TimeUnixNano is required, see the detailed comments above Metric.  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970. */
		var timeUnixNano: String?
		var asDouble: Double?
		var asInt: String?
		var exemplars: [V1Exemplar]?
		/** Flags that apply to this specific data point.  See DataPointFlags for the available flags and their meaning. */
		var flags: Int64?

		init(attributes: [V1KeyValue]? = nil, startTimeUnixNano: String? = nil, timeUnixNano: String? = nil, asDouble: Double? = nil, asInt: String? = nil, exemplars: [V1Exemplar]? = nil, flags: Int64? = nil) {
			self.attributes = attributes
			self.startTimeUnixNano = startTimeUnixNano
			self.timeUnixNano = timeUnixNano
			self.asDouble = asDouble
			self.asInt = asInt
			self.exemplars = exemplars
			self.flags = flags
		}

		enum CodingKeys: String, CodingKey, CaseIterable {
			case attributes
			case startTimeUnixNano
			case timeUnixNano
			case asDouble
			case asInt
			case exemplars
			case flags
		}

		// Encodable protocol methods

		func encode(to encoder: Encoder) throws {
			var container = encoder.container(keyedBy: CodingKeys.self)
			try container.encodeIfPresent(attributes, forKey: .attributes)
			try container.encodeIfPresent(startTimeUnixNano, forKey: .startTimeUnixNano)
			try container.encodeIfPresent(timeUnixNano, forKey: .timeUnixNano)
			try container.encodeIfPresent(asDouble, forKey: .asDouble)
			try container.encodeIfPresent(asInt, forKey: .asInt)
			try container.encodeIfPresent(exemplars, forKey: .exemplars)
			try container.encodeIfPresent(flags, forKey: .flags)
		}
	}
}
